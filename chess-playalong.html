<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chess Playalong</title>
    
    <!-- Chess libraries -->
    <link rel="stylesheet" href="https://unpkg.com/@chrisoakman/chessboardjs@1.0.0/dist/chessboard-1.0.0.min.css">
    
    <!-- Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500;600&family=Playfair+Display:wght@600;700&display=swap" rel="stylesheet">
    
    <style>
        :root {
            --bg-primary: #1a1a1a;
            --bg-secondary: #242424;
            --bg-tertiary: #2e2e2e;
            --text-primary: #e8e8e8;
            --text-secondary: #a0a0a0;
            --text-muted: #666;
            --accent-green: #7fba6a;
            --accent-amber: #d4a03c;
            --accent-red: #c75d5d;
            --accent-blue: #5d8ac7;
            --border-color: #3a3a3a;
            --board-light: #d4c4a8;
            --board-dark: #8b7355;
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'JetBrains Mono', monospace;
            background: var(--bg-primary);
            color: var(--text-primary);
            min-height: 100vh;
            line-height: 1.6;
        }
        
        .app-container {
            display: grid;
            grid-template-columns: 480px 1fr;
            gap: 32px;
            max-width: 1400px;
            margin: 0 auto;
            padding: 32px;
            min-height: 100vh;
        }
        
        /* Header */
        .header {
            grid-column: 1 / -1;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding-bottom: 24px;
            border-bottom: 1px solid var(--border-color);
        }
        
        .logo {
            font-family: 'Playfair Display', serif;
            font-size: 28px;
            font-weight: 700;
            letter-spacing: -0.5px;
        }
        
        .logo span {
            color: var(--accent-amber);
        }
        
        .controls {
            display: flex;
            gap: 12px;
        }
        
        .btn {
            font-family: inherit;
            font-size: 13px;
            padding: 10px 18px;
            border: 1px solid var(--border-color);
            background: var(--bg-secondary);
            color: var(--text-primary);
            cursor: pointer;
            transition: all 0.15s ease;
            border-radius: 4px;
        }
        
        .btn:hover {
            background: var(--bg-tertiary);
            border-color: var(--text-muted);
        }
        
        .btn-primary {
            background: var(--accent-amber);
            border-color: var(--accent-amber);
            color: var(--bg-primary);
            font-weight: 600;
        }
        
        .btn-primary:hover {
            background: #e0ac48;
            border-color: #e0ac48;
        }
        
        /* Board section */
        .board-section {
            display: flex;
            flex-direction: column;
            gap: 16px;
        }
        
        #board {
            width: 480px;
            border: 2px solid var(--border-color);
            border-radius: 4px;
            overflow: hidden;
        }
        
        /* Override chessboard colors */
        .white-1e1d7 {
            background-color: var(--board-light) !important;
        }
        
        .black-3c85d {
            background-color: var(--board-dark) !important;
        }
        
        .game-info {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 16px;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            font-size: 13px;
        }
        
        .turn-indicator {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .turn-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: var(--text-primary);
        }
        
        .turn-dot.black {
            background: var(--bg-primary);
            border: 2px solid var(--text-primary);
        }
        
        .move-count {
            color: var(--text-secondary);
        }
        
        /* Analysis section */
        .analysis-section {
            display: flex;
            flex-direction: column;
            gap: 20px;
            overflow-y: auto;
            max-height: calc(100vh - 140px);
        }
        
        .panel {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            overflow: hidden;
        }
        
        .panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 14px 18px;
            background: var(--bg-tertiary);
            border-bottom: 1px solid var(--border-color);
        }
        
        .panel-title {
            font-size: 12px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: var(--text-secondary);
        }
        
        .panel-status {
            font-size: 11px;
            color: var(--text-muted);
        }
        
        .panel-content {
            padding: 18px;
        }
        
        /* Opening panel */
        .opening-name {
            font-family: 'Playfair Display', serif;
            font-size: 20px;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--accent-amber);
        }
        
        .opening-eco {
            font-size: 12px;
            color: var(--text-muted);
            margin-bottom: 16px;
        }
        
        .opening-stats {
            display: flex;
            gap: 24px;
            font-size: 12px;
        }
        
        .stat {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }
        
        .stat-label {
            color: var(--text-muted);
            font-size: 10px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .stat-value {
            font-weight: 600;
        }
        
        .stat-value.white { color: var(--text-primary); }
        .stat-value.draw { color: var(--text-secondary); }
        .stat-value.black { color: var(--text-muted); }
        
        /* Engine panel */
        .engine-depth {
            font-size: 11px;
            color: var(--accent-green);
        }
        
        .move-list {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }
        
        .move-item {
            display: grid;
            grid-template-columns: auto 60px 1fr;
            gap: 16px;
            align-items: start;
            padding: 14px;
            background: var(--bg-tertiary);
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.15s ease;
            border: 1px solid transparent;
        }
        
        .move-item:hover {
            border-color: var(--border-color);
        }
        
        .move-item.best {
            border-color: var(--accent-green);
            border-width: 1px;
        }
        
        .move-rank {
            font-size: 11px;
            color: var(--text-muted);
            font-weight: 600;
            padding-top: 2px;
        }
        
        .move-notation {
            font-size: 18px;
            font-weight: 600;
            font-family: 'Playfair Display', serif;
        }
        
        .move-eval {
            font-size: 13px;
            font-weight: 600;
            padding-top: 4px;
        }
        
        .move-eval.positive { color: var(--accent-green); }
        .move-eval.negative { color: var(--accent-red); }
        .move-eval.neutral { color: var(--text-secondary); }
        
        .move-explanation {
            font-size: 13px;
            color: var(--text-secondary);
            line-height: 1.5;
        }
        
        .move-explanation.loading {
            color: var(--text-muted);
            font-style: italic;
        }
        
        /* Empty states */
        .empty-state {
            text-align: center;
            padding: 32px;
            color: var(--text-muted);
            font-size: 13px;
        }
        
        /* Move history */
        .move-history {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            font-size: 12px;
        }
        
        .move-pair {
            display: flex;
            gap: 6px;
            padding: 4px 8px;
            background: var(--bg-tertiary);
            border-radius: 3px;
        }
        
        .move-number {
            color: var(--text-muted);
        }
        
        .move-white, .move-black {
            cursor: pointer;
        }
        
        .move-white:hover, .move-black:hover {
            color: var(--accent-amber);
        }
        
        /* API Key Modal */
        .modal-overlay {
            display: none;
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.7);
            z-index: 100;
            align-items: center;
            justify-content: center;
        }
        
        .modal-overlay.active {
            display: flex;
        }
        
        .modal {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 28px;
            width: 100%;
            max-width: 440px;
        }
        
        .modal h2 {
            font-family: 'Playfair Display', serif;
            font-size: 22px;
            margin-bottom: 12px;
        }
        
        .modal p {
            color: var(--text-secondary);
            font-size: 13px;
            margin-bottom: 20px;
        }
        
        .modal input {
            width: 100%;
            padding: 12px 14px;
            font-family: inherit;
            font-size: 13px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            color: var(--text-primary);
            margin-bottom: 16px;
        }
        
        .modal input:focus {
            outline: none;
            border-color: var(--accent-amber);
        }
        
        .modal-buttons {
            display: flex;
            gap: 12px;
            justify-content: flex-end;
        }
        
        /* Scrollbar */
        ::-webkit-scrollbar {
            width: 8px;
        }
        
        ::-webkit-scrollbar-track {
            background: var(--bg-primary);
        }
        
        ::-webkit-scrollbar-thumb {
            background: var(--border-color);
            border-radius: 4px;
        }
        
        ::-webkit-scrollbar-thumb:hover {
            background: var(--text-muted);
        }
        
        /* Responsive */
        @media (max-width: 1000px) {
            .app-container {
                grid-template-columns: 1fr;
                padding: 16px;
            }
            
            #board {
                width: 100%;
                max-width: 480px;
            }
            
            .analysis-section {
                max-height: none;
            }
        }
    </style>
</head>
<body>
    <div class="app-container">
        <header class="header">
            <div class="logo">Chess<span>Playalong</span></div>
            <div class="controls">
                <button class="btn" id="undoBtn">← Undo</button>
                <button class="btn" id="flipBtn">Flip Board</button>
                <button class="btn btn-primary" id="newGameBtn">New Game</button>
            </div>
        </header>
        
        <div class="board-section">
            <div id="board"></div>
            <div class="game-info">
                <div class="turn-indicator">
                    <div class="turn-dot" id="turnDot"></div>
                    <span id="turnText">White to move</span>
                </div>
                <div class="move-count" id="moveCount">Move 1</div>
            </div>
            
            <div class="panel">
                <div class="panel-header">
                    <span class="panel-title">Move History</span>
                </div>
                <div class="panel-content">
                    <div class="move-history" id="moveHistory">
                        <div class="empty-state">No moves yet</div>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="analysis-section">
            <div class="panel">
                <div class="panel-header">
                    <span class="panel-title">Opening Book</span>
                    <span class="panel-status" id="openingStatus">Lichess Masters DB</span>
                </div>
                <div class="panel-content" id="openingContent">
                    <div class="opening-name">Starting Position</div>
                    <div class="opening-eco"></div>
                    <div class="opening-stats">
                        <div class="stat">
                            <span class="stat-label">Games</span>
                            <span class="stat-value">—</span>
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="panel">
                <div class="panel-header">
                    <span class="panel-title">Engine Analysis</span>
                    <span class="panel-status engine-depth" id="engineDepth">Initializing...</span>
                </div>
                <div class="panel-content">
                    <div class="move-list" id="moveList">
                        <div class="empty-state">Analyzing position...</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- API Key Modal -->
    <div class="modal-overlay" id="apiKeyModal">
        <div class="modal">
            <h2>Claude API Key</h2>
            <p>Enter your Anthropic API key to enable AI-powered move explanations. Your key is stored locally and never sent anywhere except Anthropic's API.</p>
            <input type="password" id="apiKeyInput" placeholder="sk-ant-...">
            <div class="modal-buttons">
                <button class="btn" id="skipApiKey">Skip for now</button>
                <button class="btn btn-primary" id="saveApiKey">Save Key</button>
            </div>
        </div>
    </div>
    
    <!-- Load scripts in order -->
    <script src="https://code.jquery.com/jquery-3.7.1.min.js"></script>
    <script src="https://unpkg.com/@chrisoakman/chessboardjs@1.0.0/dist/chessboard-1.0.0.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/chess.js/0.10.3/chess.min.js"></script>
    
    <script>
        // ============================================
        // State
        // ============================================
        let board = null;
        let game = new Chess();
        let boardFlipped = false;
        let stockfish = null;
        let currentAnalysis = [];
        let apiKey = localStorage.getItem('anthropic_api_key') || '';
        let analysisTimeout = null;
        
        // ============================================
        // Initialize
        // ============================================
        function init() {
            initBoard();
            initStockfish();
            
            // Show API key modal if no key stored
            if (!apiKey) {
                document.getElementById('apiKeyModal').classList.add('active');
            }
            
            // Initial analysis
            analyzePosition();
        }
        
        function initBoard() {
            const config = {
                draggable: true,
                position: 'start',
                pieceTheme: 'https://chessboardjs.com/img/chesspieces/wikipedia/{piece}.png',
                onDrop: handleMove,
                onDragStart: onDragStart
            };
            
            board = Chessboard('board', config);
            
            // Bind buttons
            document.getElementById('newGameBtn').addEventListener('click', newGame);
            document.getElementById('undoBtn').addEventListener('click', undoMove);
            document.getElementById('flipBtn').addEventListener('click', flipBoard);
            document.getElementById('saveApiKey').addEventListener('click', saveApiKey);
            document.getElementById('skipApiKey').addEventListener('click', () => {
                document.getElementById('apiKeyModal').classList.remove('active');
            });
            
            // Resize handling
            window.addEventListener('resize', () => board.resize());
        }
        
        async function initStockfish() {
            try {
                // Fetch Stockfish script and create a Blob URL to work around CORS restrictions
                const response = await fetch('https://unpkg.com/stockfish.js@10.0.2/stockfish.js');
                const blob = await response.blob();
                const blobUrl = URL.createObjectURL(blob);

                stockfish = new Worker(blobUrl);
                stockfish.onmessage = handleStockfishMessage;
                stockfish.postMessage('uci');
                stockfish.postMessage('setoption name MultiPV value 4');
                stockfish.postMessage('isready');
            } catch (e) {
                console.error('Failed to initialize Stockfish:', e);
                document.getElementById('engineDepth').textContent = 'Engine unavailable';
                document.getElementById('moveList').innerHTML = `
                    <div class="empty-state">
                        <p>Failed to load chess engine.</p>
                        <p style="margin-top: 8px; font-size: 11px; color: var(--text-muted);">
                            ${e.message}
                        </p>
                    </div>`;
            }
        }
        
        // ============================================
        // Board interaction
        // ============================================
        function onDragStart(source, piece, position, orientation) {
            // Allow moving any piece (we're mirroring a game)
            // Use game_over() for chess.js 0.10.x compatibility
            if (game.game_over()) return false;
            return true;
        }
        
        function handleMove(source, target) {
            // Try the move
            const move = game.move({
                from: source,
                to: target,
                promotion: 'q' // Auto-promote to queen for now
            });
            
            if (move === null) return 'snapback';
            
            updateDisplay();
            analyzePosition();
        }
        
        function newGame() {
            game.reset();
            board.start();
            updateDisplay();
            analyzePosition();
        }
        
        function undoMove() {
            game.undo();
            board.position(game.fen());
            updateDisplay();
            analyzePosition();
        }
        
        function flipBoard() {
            boardFlipped = !boardFlipped;
            board.flip();
        }
        
        // ============================================
        // Display updates
        // ============================================
        function updateDisplay() {
            // Turn indicator
            const isWhite = game.turn() === 'w';
            document.getElementById('turnDot').className = 'turn-dot' + (isWhite ? '' : ' black');
            document.getElementById('turnText').textContent = isWhite ? 'White to move' : 'Black to move';
            
            // Move count
            const fullMoves = Math.floor(game.history().length / 2) + 1;
            document.getElementById('moveCount').textContent = `Move ${fullMoves}`;
            
            // Move history
            updateMoveHistory();
        }
        
        function updateMoveHistory() {
            const history = game.history();
            const container = document.getElementById('moveHistory');
            
            if (history.length === 0) {
                container.innerHTML = '<div class="empty-state">No moves yet</div>';
                return;
            }
            
            let html = '';
            for (let i = 0; i < history.length; i += 2) {
                const moveNum = Math.floor(i / 2) + 1;
                const whiteMove = history[i];
                const blackMove = history[i + 1] || '';
                
                html += `<div class="move-pair">
                    <span class="move-number">${moveNum}.</span>
                    <span class="move-white">${whiteMove}</span>
                    ${blackMove ? `<span class="move-black">${blackMove}</span>` : ''}
                </div>`;
            }
            
            container.innerHTML = html;
        }
        
        // ============================================
        // Stockfish Analysis
        // ============================================
        let analysisLines = {};
        let currentDepth = 0;
        
        function analyzePosition() {
            // Clear previous analysis
            analysisLines = {};
            currentDepth = 0;
            document.getElementById('engineDepth').textContent = 'Analyzing...';
            document.getElementById('moveList').innerHTML = '<div class="empty-state">Analyzing position...</div>';
            
            // Debounce analysis
            if (analysisTimeout) clearTimeout(analysisTimeout);
            
            analysisTimeout = setTimeout(() => {
                if (stockfish) {
                    stockfish.postMessage('stop');
                    stockfish.postMessage(`position fen ${game.fen()}`);
                    stockfish.postMessage('go depth 18');
                }

                // Also fetch opening book data
                fetchOpeningData();
            }, 100);
        }
        
        function handleStockfishMessage(event) {
            const line = event.data;
            
            if (line.startsWith('info depth')) {
                parseAnalysisLine(line);
            } else if (line.startsWith('bestmove')) {
                finalizeAnalysis();
            }
        }
        
        function parseAnalysisLine(line) {
            const depthMatch = line.match(/depth (\d+)/);
            const multipvMatch = line.match(/multipv (\d+)/);
            const scoreMatch = line.match(/score (cp|mate) (-?\d+)/);
            const pvMatch = line.match(/ pv (.+)/);
            
            if (!depthMatch || !multipvMatch || !scoreMatch || !pvMatch) return;
            
            const depth = parseInt(depthMatch[1]);
            const multipv = parseInt(multipvMatch[1]);
            const scoreType = scoreMatch[1];
            const scoreValue = parseInt(scoreMatch[2]);
            const pv = pvMatch[1].split(' ');
            
            // Only update if this is a new depth for this line
            if (depth >= currentDepth) {
                currentDepth = depth;
                
                // Convert UCI move to SAN
                const tempGame = new Chess(game.fen());
                const uciMove = pv[0];
                const from = uciMove.substring(0, 2);
                const to = uciMove.substring(2, 4);
                const promotion = uciMove.length > 4 ? uciMove[4] : undefined;
                
                const move = tempGame.move({ from, to, promotion });
                if (!move) return;
                
                // Calculate eval from current player's perspective
                let evalScore;
                if (scoreType === 'mate') {
                    evalScore = scoreValue > 0 ? `M${scoreValue}` : `M${scoreValue}`;
                } else {
                    // Stockfish gives score from white's perspective
                    const cpScore = game.turn() === 'w' ? scoreValue : -scoreValue;
                    evalScore = (cpScore / 100).toFixed(2);
                    if (cpScore > 0) evalScore = '+' + evalScore;
                }
                
                analysisLines[multipv] = {
                    move: move.san,
                    uci: uciMove,
                    eval: evalScore,
                    depth: depth,
                    pv: pv
                };
                
                // Update display at certain depths
                if (depth >= 10 && depth % 2 === 0) {
                    updateAnalysisDisplay();
                }
            }
        }
        
        function finalizeAnalysis() {
            updateAnalysisDisplay();
            
            // Fetch Claude explanations for top moves
            if (apiKey) {
                fetchExplanations();
            }
        }
        
        function updateAnalysisDisplay() {
            document.getElementById('engineDepth').textContent = `Depth ${currentDepth}`;
            
            const moves = Object.values(analysisLines).sort((a, b) => {
                // Sort by eval (best first)
                const evalA = parseEval(a.eval);
                const evalB = parseEval(b.eval);
                return evalB - evalA;
            });
            
            if (moves.length === 0) {
                document.getElementById('moveList').innerHTML = '<div class="empty-state">No legal moves</div>';
                return;
            }
            
            currentAnalysis = moves;
            
            let html = '';
            moves.forEach((m, i) => {
                const evalClass = getEvalClass(m.eval);
                const isBest = i === 0;
                
                html += `<div class="move-item${isBest ? ' best' : ''}" data-move="${m.uci}">
                    <span class="move-rank">#${i + 1}</span>
                    <div>
                        <div class="move-notation">${m.move}</div>
                        <div class="move-eval ${evalClass}">${m.eval}</div>
                    </div>
                    <div class="move-explanation ${!apiKey ? '' : 'loading'}" id="explanation-${i}">
                        ${!apiKey ? 'Add API key for explanations' : 'Generating explanation...'}
                    </div>
                </div>`;
            });
            
            document.getElementById('moveList').innerHTML = html;
            
            // Add click handlers to preview moves
            document.querySelectorAll('.move-item').forEach(el => {
                el.addEventListener('click', () => {
                    const uci = el.dataset.move;
                    previewMove(uci);
                });
            });
        }
        
        function parseEval(evalStr) {
            if (evalStr.startsWith('M')) {
                const mateIn = parseInt(evalStr.substring(1));
                return mateIn > 0 ? 10000 - mateIn : -10000 - mateIn;
            }
            return parseFloat(evalStr);
        }
        
        function getEvalClass(evalStr) {
            if (evalStr.startsWith('M')) {
                return parseInt(evalStr.substring(1)) > 0 ? 'positive' : 'negative';
            }
            const val = parseFloat(evalStr);
            if (val > 0.3) return 'positive';
            if (val < -0.3) return 'negative';
            return 'neutral';
        }
        
        function previewMove(uci) {
            // Briefly show the move on the board
            const from = uci.substring(0, 2);
            const to = uci.substring(2, 4);
            
            // Highlight squares
            document.querySelectorAll('.square-55d63').forEach(sq => {
                sq.style.boxShadow = '';
            });
            
            const fromSq = document.querySelector(`.square-${from}`);
            const toSq = document.querySelector(`.square-${to}`);
            
            if (fromSq) fromSq.style.boxShadow = 'inset 0 0 0 4px rgba(212, 160, 60, 0.6)';
            if (toSq) toSq.style.boxShadow = 'inset 0 0 0 4px rgba(212, 160, 60, 0.6)';
            
            // Clear highlights after a moment
            setTimeout(() => {
                if (fromSq) fromSq.style.boxShadow = '';
                if (toSq) toSq.style.boxShadow = '';
            }, 1500);
        }
        
        // ============================================
        // Opening Book
        // ============================================
        async function fetchOpeningData() {
            const fen = game.fen();
            
            try {
                // Lichess masters database
                const response = await fetch(`https://explorer.lichess.ovh/masters?fen=${encodeURIComponent(fen)}`);
                const data = await response.json();
                
                updateOpeningDisplay(data);
            } catch (e) {
                console.error('Opening fetch error:', e);
                document.getElementById('openingContent').innerHTML = `
                    <div class="opening-name">Unknown Position</div>
                    <div class="opening-eco">Not in opening book</div>
                `;
            }
        }
        
        function updateOpeningDisplay(data) {
            const content = document.getElementById('openingContent');
            
            if (!data.opening && data.moves.length === 0) {
                content.innerHTML = `
                    <div class="opening-name">Out of Book</div>
                    <div class="opening-eco">Position not in masters database</div>
                `;
                return;
            }
            
            const opening = data.opening || { name: 'Starting Position', eco: '' };
            const total = data.white + data.draws + data.black || 1;
            const whitePercent = ((data.white / total) * 100).toFixed(1);
            const drawPercent = ((data.draws / total) * 100).toFixed(1);
            const blackPercent = ((data.black / total) * 100).toFixed(1);
            
            content.innerHTML = `
                <div class="opening-name">${opening.name || 'Starting Position'}</div>
                <div class="opening-eco">${opening.eco || ''}</div>
                <div class="opening-stats">
                    <div class="stat">
                        <span class="stat-label">Games</span>
                        <span class="stat-value">${total.toLocaleString()}</span>
                    </div>
                    <div class="stat">
                        <span class="stat-label">White wins</span>
                        <span class="stat-value white">${whitePercent}%</span>
                    </div>
                    <div class="stat">
                        <span class="stat-label">Draws</span>
                        <span class="stat-value draw">${drawPercent}%</span>
                    </div>
                    <div class="stat">
                        <span class="stat-label">Black wins</span>
                        <span class="stat-value black">${blackPercent}%</span>
                    </div>
                </div>
            `;
        }
        
        // ============================================
        // Claude Explanations
        // ============================================
        async function fetchExplanations() {
            if (!apiKey || currentAnalysis.length === 0) return;
            
            const fen = game.fen();
            const turn = game.turn() === 'w' ? 'White' : 'Black';
            const moves = currentAnalysis.slice(0, 4).map(m => `${m.move} (eval: ${m.eval})`).join(', ');
            
            const prompt = `You are a chess coach. Analyze this position and explain each candidate move concisely.

Position (FEN): ${fen}
${turn} to move.

Top engine moves: ${moves}

For each move, give a 1-2 sentence explanation of the strategic or tactical idea. Focus on:
- What the move accomplishes
- Any threats created or prevented
- Positional considerations

Format your response as:
MOVE: explanation
MOVE: explanation
...

Be concise and insightful, like a strong club player explaining to an improving student.`;

            try {
                const response = await fetch('https://api.anthropic.com/v1/messages', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'x-api-key': apiKey,
                        'anthropic-version': '2023-06-01',
                        'anthropic-dangerous-direct-browser-access': 'true'
                    },
                    body: JSON.stringify({
                        model: 'claude-sonnet-4-20250514',
                        max_tokens: 1024,
                        messages: [{ role: 'user', content: prompt }]
                    })
                });
                
                if (!response.ok) {
                    throw new Error(`API error: ${response.status}`);
                }
                
                const data = await response.json();
                const text = data.content[0].text;
                
                // Parse explanations
                const explanations = parseExplanations(text);
                
                // Update display
                currentAnalysis.forEach((m, i) => {
                    const el = document.getElementById(`explanation-${i}`);
                    if (el) {
                        el.classList.remove('loading');
                        el.textContent = explanations[m.move] || 'No explanation available';
                    }
                });
                
            } catch (e) {
                console.error('Claude API error:', e);
                currentAnalysis.forEach((m, i) => {
                    const el = document.getElementById(`explanation-${i}`);
                    if (el) {
                        el.classList.remove('loading');
                        el.textContent = 'Error fetching explanation';
                    }
                });
            }
        }
        
        function parseExplanations(text) {
            const explanations = {};
            const lines = text.split('\n');
            
            for (const line of lines) {
                // Match patterns like "e4: explanation" or "1. e4: explanation" or "**e4**: explanation"
                const match = line.match(/^\*?\*?(\d+\.\s*)?([KQRBN]?[a-h]?[1-8]?x?[a-h][1-8](?:=[QRBN])?[+#]?)\*?\*?[:\s]+(.+)/);
                if (match) {
                    const move = match[2];
                    const explanation = match[3].trim();
                    explanations[move] = explanation;
                }
            }
            
            return explanations;
        }
        
        // ============================================
        // API Key management
        // ============================================
        function saveApiKey() {
            const input = document.getElementById('apiKeyInput');
            apiKey = input.value.trim();
            
            if (apiKey) {
                localStorage.setItem('anthropic_api_key', apiKey);
                document.getElementById('apiKeyModal').classList.remove('active');
                
                // Re-fetch explanations
                if (currentAnalysis.length > 0) {
                    fetchExplanations();
                }
            }
        }
        
        // ============================================
        // Start
        // ============================================
        document.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>
